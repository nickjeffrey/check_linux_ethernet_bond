#!/usr/bin/perl -w



# DESCRIPTION
# -----------
#  This script is a nagios check that determines the health status of all ethernet bonds on a Linux host


# OUTSTANDING TASKS
# ----------------
#  


# CHANGE LOG
# ----------
#  2022/11/28   njeffrey	Script created
#  2022/12/08   njeffrey	If all ports in a bond are currently up, set alert threshold for "Link Failure Count" to 100 
#  2026/01/04   njeffrey	Add support for 802.ad LACP bonds



# NOTES
# -----
#
#  This script should return one (and only one) line of ouput.  Multiple
#  lines of output are silently ignored by nagios.
#
#  The line of output will become the body of the alert message sent by nagios
#
#
#  You will need a section in the services.cfg
#  file on the nagios server that looks similar to the following.
#   define service{
#           use                             generic-24x7-service
#           host_name                       linux01.example.com
#           service_description             NIC bonds
#           check_command                   check_by_ssh!"/usr/local/nagios/libexec/check_linux_ethernet_bond"
#           }
#
#
#
#
# Linux bonding modes and top-of-rack ethernet switch requirements
# ----------------------------------------------------------------
# mode 0 (balance-rr)     Requires static EtherChannel enabled, not LACP-negotiated.
# mode 1 (active-backup)  No configuration required on the switch.
# mode 2 (balance-xor)    Requires static EtherChannel enabled, not LACP-negotiated.
# mode 3 (broadcast)      Requires static EtherChannel enabled, not LACP-negotiated.
# mode 4 (802.3ad)        Requires LACP-negotiated EtherChannel enabled.
# mode 5 (balance-tlb)    No configuration required on the switch.
# mode 6 (balance-alb)    No configuration required on the switch.
#
# HINT: for no switch config, active-backup is the easiest, or use 802.3ad for more bandwidth




use strict;                                     #enforce good coding practices
use Getopt::Long;                               #allow --long-switches to be used as parameters
use warnings;					#use verbose warnings


# declare variables
my ($OK,$WARN,$CRITICAL,$UNKNOWN);
my ($CHECK_NAME,$host);
my ($cmd,$key,$common_output_data,$perf_data);
my ($output_message,$output_filename,$output_file_age);
my (%bond_details,$bond,@slave_interface_names,$interface_name,$interface_detail);
my ($opt_h,$opt_v,$opt_b);
my ($verbose);
my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);
my ($scratch,$count); 
$CHECK_NAME= "NIC bond";
$verbose = "no";                                #for debugging
$output_filename = "/tmp/nagios.check_linux_ethernet_bond.tmp";  #temporary filename created by script
#
# Nagios return codes
#
$OK       = 0;
$WARN     = 1;
$CRITICAL = 2;
$UNKNOWN  = 3;


sub get_options {
   #
   # this gets the command line parameters provided by the users
   print "running get_options subroutine \n" if ($verbose eq "yes");
   #
   Getopt::Long::Configure('bundling');
   GetOptions(
      "h"   => \$opt_h, "help"        => \$opt_h,
      "v"   => \$opt_v, "verbose"     => \$opt_v,
      "b=s" => \$opt_b, "bond=s"      => \$opt_b,
   );
   #
   # see if user provided -v or --verbose switch
   if ( defined($opt_v) ) {
      $verbose = "yes";
   }                                                    #end of if block
   #
   # see if user provided -b or --bond switch
   if ( defined($opt_b) ) {
      $bond = $opt_b;
   }                                                    #end of if block
   #
   #
   # see if user provided -h or --help switch
   if ( (defined($opt_h)) ) {
      print "Nagios plugin for determining health of Linux ethernet bonds \n";
      print "$0 [options]  \n";
      print "    where options are: \n";
      print "    -h --help \n";
      print "    -v --verbose \n";
      print "    --bond=bond0 (optional, will check all bonds by default)\n";
      print "\n\n";
      exit;
   }                                                    #end of if block
}                       #end of subroutine




sub sanity_checks {
   #
   print "running sanity_checks subroutine \n" if ($verbose eq "yes");
   #
   #
   # Confirm required files exist
   #
   if ( ! -d "/proc/net/bonding" ) {
      print "$CHECK_NAME UNKNOWN - cannot find /proc/net/bonding directory, is the bonding kernel module installed? \n";
      exit $UNKNOWN;                                    #exit script
   }
}                                               #end of subroutine



sub check_for_output_file {
   #
   # a cron job may have already created the output file that we need
   #
   print "running check_for_output_file subroutine \n" if ($verbose eq "yes");
   #
   #
   # delete the output file if it is more than 4 minutes (240 seconds) old (this will work when run via root user but not when run as nagios user due to permissions)
   if ( -e "$output_filename" )  {                                      #see if a cron job has already provided the info we need
      ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($output_filename); #get last modification time in seconds since the epoch
      $output_file_age = time - $mtime;                                 #figure out how many seconds old the file is
      print "   output file $output_filename is $output_file_age seconds old \n" if ($verbose eq "yes");
      if ( $output_file_age >= 60 ) {                                  #see if the file is more than 60 seconds old
         if ( -w $output_filename )  {                                  #file is writable if this script executed by root, but read-only when executed via nagios
            print "   deleting old copy of $output_filename \n" if ($verbose eq "yes");
            unlink "$output_filename";                                  #delete the file if it is too old
         }
      }
      if ( (-e "$output_filename") && ($output_file_age >= 900) ) {        #raise an alert if the file is more than 900 seconds old
         print "$CHECK_NAME WARN - temporary file $output_filename not being automatically created via cron.  Please investigate. \n";
         exit $WARN;                                                    #exit script
      }                                                                 #end of if block
   }                                                                    #end of if block
   #
   if ( -e "$output_filename" ) {                                       #see if a cron job has already provided the info we need
      open (OUT,"$output_filename") or die "Cannot open $output_filename for reading $! \n";
      while (<OUT>) {                                                   #read a line from the text file
         $output_message = $_  if ( $_ =~ /[a-zA-Z]/);                  #get the content of the output file into a variable
         print "   output message is $output_message \n" if ($verbose eq "yes");
      }                                                                 #end of while loop
      close OUT;                                                        #close filehandle
      print $output_message;                                            #print the content of the output file
      exit $CRITICAL if ( $output_message =~ /CRITICAL/ );              #exit script with appropriate return code
      exit $WARN     if ( $output_message =~ /WARN/ );                  #exit script with appropriate return code
      exit $UNKNOWN  if ( $output_message =~ /UNKNOWN/ );               #exit script with appropriate return code
      exit $OK       if ( $output_message =~ /OK/ );                    #exit script with appropriate return code
   }                                                                    #end of if block
}                                                                       #end of subroutine




sub print_to_outputfile {
   #
   print "running print_to_outputfile \n" if ($verbose eq "yes");
   #
   # This subroutine is called whenever an output message is printed, to confirm that the $output_file exists
   #
   # confirm the output message exists
   $output_message = "$CHECK_NAME UNKNOWN - could not parse response from remote host \n" unless ($output_message);
   #
   # confirm the $output_filename variable is defined
   unless ($output_filename) {
      print "$CHECK_NAME UNKNOWN - the \$output_filename variable is not defined.  This might be a script bug. \n";
      exit $UNKNOWN;                                                            #only get this far if OK/WARN/CRITICAL/UNKNOWN was not found in the output file
   }                                                                            #end of unless block
   #
   if ( ! -e "$output_filename" ) {                                                     #only run this section if $output_filename does not already exist
      print "   $output_filename not found - writing output message to $output_filename \n" if ($verbose eq "yes");
      open (OUT,">$output_filename") or die "Cannot open $output_filename for writing: $! \n";
      print OUT "$output_message";
      close OUT;                                                                #close filehandle
      chmod 0644, "$output_filename";                                           #set the file permission to -rw-r--r-- to ensure nagios user can read file
   }                                                                            #end of if block
}                                                                               #end of subroutine





############################################
# Helper subroutines for housekeeping tasks
############################################

sub normalize_key {
   #
   #print "running normalize_key subroutine \n" if ($verbose eq "yes");
   #
   # this subroutine converts arbitrary text keys from /proc/net/bonding/* into safe consistent hash keys
   my ($k) = @_;				#extract the input
   $k = lc $k;					#convert to lowercase to simplify regex matching
   $k =~ s/[^a-z0-9]+/_/g;			#replace multiple non-alphanumeric characters with a single underscore
   $k =~ s/^_+|_+$//g;				#remove leading or trailing underscores
   return $k; 					#return the normalized key
}



sub parse_kv_line {
   #
   #print "running parse_kv_line subroutine \n" if ($verbose eq "yes");
   #
   # this subroutine parses key:value lines and returns (key,value), or returns nothing if the line is not a key:value pair
   my ($line) = @_;
   return unless $line =~ /^\s*([^:]+?)\s*:\s*(.*?)\s*$/; 	#key is anything before : value is anything after :
   return ( normalize_key($1), $2 );				#call other subroutine to cleanup formatting, remove spaces, etc.
}



sub worst_rc {				
   #
   print "      running worst_rc subroutine \n" if ($verbose eq "yes");
   #
   #subroutine to merge multiple Nagios return code into a single "worst" return code
   #the idea here is if there are multiple ethernet bonds, the return code should be for the most critical error
   #
   my ($a, $b) = @_;
   # UNKNOWN always wins
   return 3 if $a == 3 || $b == 3;
   return ($a > $b) ? $a : $b;
}



sub rc_label {
   #
   print "      running rc_label subroutine \n" if ($verbose eq "yes");
   #
   my ($rc) = @_;
   return ($rc == 0) ? 'OK' :
          ($rc == 1) ? 'WARNING' :
          ($rc == 2) ? 'CRITICAL' : 'UNKNOWN';
}



############################################
# Parser: one bond file
# This subroutine reads one file from /proc/net/bonding/*
############################################

sub parse_bond_file_text {
   #
   print "      running parse_bond_file_text subroutine \n" if ($verbose eq "yes");
   #
   my ($txt) = @_;

   my %out = (
      top   => {},
      blocks => {},
      slaves => {},
   );

   my $section   = 'top';
   my $block_name;
   my $cur_slave;
   my $subblock;

   for my $line (split /\n/, $txt) {
      $line =~ s/\r$//;
      next if $line =~ /^\s*$/;

      # Slave stanza
      if ($line =~ /^Slave Interface:\s+(\S+)/) {
         $cur_slave = $1;
         $out{slaves}{$cur_slave} ||= { top => {}, blocks => {} };
         $subblock = undef;
         next;
      }

      # details actor/partner lacp pdu (inside slave)
      if (defined $cur_slave && $line =~ /^\s*details\s+(.+?)\s*:\s*$/i) {
         $subblock = normalize_key("details_$1");
         $out{slaves}{$cur_slave}{blocks}{$subblock} ||= {};
         next;
      }

      # Global block header (with colon)
      if (!defined $cur_slave &&
         $line =~ /^([A-Za-z0-9][A-Za-z0-9 .\/_-]*)\s*:\s*$/) {

         $block_name = normalize_key($1);
         $out{blocks}{$block_name} ||= {};
         next;
      }

      # Global block header (no colon)
      if (!defined $cur_slave &&
         $line =~ /^([0-9A-Za-z][0-9A-Za-z .\/_-]*)$/ &&
         $line !~ /:/) {

         $block_name = normalize_key($1);
         $out{blocks}{$block_name} ||= {};
         next;
      }

      # Key/value line
      my ($k, $v) = parse_kv_line($line);
      next unless defined $k;

      if (defined $cur_slave) {
         if (defined $subblock) {
            $out{slaves}{$cur_slave}{blocks}{$subblock}{$k} = $v;
         } else {
            $out{slaves}{$cur_slave}{top}{$k} = $v;
         }
      } else {
         if (defined $block_name) {
            $out{blocks}{$block_name}{$k} = $v;
         } else {
            $out{top}{$k} = $v;
         }
      }
   }

   return \%out;					#return parsed key:value pairs to the calling subroutine
}							#end of subroutine




############################################
# Read all bonds
# Enumeration + ingestion layer for bonding parser
# Possible enhancement, regex match will fail unless simple filenames like bond0, bond1, bond999 are used
# Cannot use filenames like My-Special-Bond999
############################################

sub read_all_bonds_into_hash {
   #
   print "   running read_all_bonds_into_hash subroutine \n" if ($verbose eq "yes");
   #
   my %bonds;						#create a hash, each ethernet bond with be one entry
   my $dir = '/proc/net/bonding';			#each file in this directory represents an ethernet bond
   print "      looking for files in $dir directory \n" if ($verbose eq "yes");

   opendir my $dh, $dir or return \%bonds;		#open directory handle
   for my $entry (sort readdir $dh) {
      next unless $entry =~ /^bond\d+$/;		#note that the filename must begin with "bond" following by any digits, will fail if crazy filenames are used!
      my $path = "$dir/$entry";
      next unless -r $path;
      print "      found file $path \n" if ($verbose eq "yes");

      open my $fh, '<', $path or next;			#open filehandle
      local $/ = undef;
      my $txt = <$fh>;					#read contents of file into scalar variable
      close $fh;					#close filehandle

      print "      calling parse_bond_file_text subroutine against $path \n" if ($verbose eq "yes");
      $bonds{$entry} = parse_bond_file_text($txt);	#call subroutine to parse all the text into key:value pairs for the hash
   }
   closedir $dh;					#close directory handle that was reading filenames from /proc/net/bonding/

   return \%bonds;
}



############################################
# Mode detection
# Figure out which of the following modes is used by each bond
# mode 0 (balance-rr)     Requires static EtherChannel enabled, not LACP-negotiated.
# mode 1 (active-backup)  No configuration required on the switch.
# mode 2 (balance-xor)    Requires static EtherChannel enabled, not LACP-negotiated.
# mode 3 (broadcast)      Requires static EtherChannel enabled, not LACP-negotiated.
# mode 4 (802.3ad)        Requires LACP-negotiated EtherChannel enabled.
# mode 5 (balance-tlb)    No configuration required on the switch.
# mode 6 (balance-alb)    No configuration required on the switch.
############################################

sub parse_mode_family {
   #
   print "      running parse_mode_family subroutine \n" if ($verbose eq "yes");
   #
   my ($mode) = @_;
   $mode //= '';					# //= means assign the right-hand value only if the left-hand value is undefined
   $mode = lc $mode;					# lc means convert to lowercase
   #
   if ($mode =~ /802\.3ad/) {
      print "         detected bond mode: $mode \n" if ($verbose eq "yes");
      return 'lacp'; 					#send this value back to the calling subroutine
   }
   elsif ($mode =~ /active-backup/) {
      print "         detected bond mode: $mode \n" if ($verbose eq "yes");
      return 'active_backup';				#send this value back to the calling subroutine
   }
   elsif ($mode =~ /balance-/) {			#this covers balance-rr balance-alb balance-tlb
      print "         detected bond mode: $mode \n" if ($verbose eq "yes");
      return 'balance'; 				#send this value back to the calling subroutine
   }
   elsif ($mode =~ /broadcast/) {
      print "         detected bond mode: $mode \n" if ($verbose eq "yes");
      return 'broadcast';				#send this value back to the calling subroutine
   }
   else { 						#only get this far if none of the bond modes were detected
      print "         Could not detect bond mode! \n" if ($verbose eq "yes");
      return 'unknown';					#send this value back to the calling subroutine	
   }
}							#end of subroutine



############################################
# Common checks
############################################

sub eval_common {
   #
   print "      running eval_common subroutine \n" if ($verbose eq "yes");
   #
   my ($B) = @_;
   my @msgs;
   my %perf;
   my $rc = 0;

   my $mii = lc(($B->{top}{mii_status} // ''));
   if ($mii ne 'up') {
      $rc = 2;
      push @msgs, "bond_mii=$mii";
   }
   #
   for my $if (keys %{ $B->{slaves} }) {
      my $lfc = $B->{slaves}{$if}{top}{link_failure_count};
      $lfc = (defined $lfc && $lfc =~ /^\d+$/) ? $lfc : 0;
      $perf{"lfc_$if"} = $lfc;
   }
   #
   return ($rc, \@msgs, \%perf);
}



############################################
# LACP evaluator (WARN degradation, CRIT outage)
############################################

sub eval_lacp {
   #
   print "   running eval_lacp subroutine \n" if ($verbose eq "yes");
   #
   my ($B) = @_;
   my ($rc, $msgs, $perf) = eval_common($B);

   my $agg = $B->{blocks}{active_aggregator_info} // {};
   my $agg_id = $agg->{aggregator_id};

   my $usable = 0;
   for my $if (keys %{ $B->{slaves} }) {
      my $S = $B->{slaves}{$if};
      my $ok = 1;

      $ok = 0 if lc(($S->{top}{mii_status} // '')) ne 'up';
      $ok = 0 if defined $agg_id && $S->{top}{aggregator_id} ne $agg_id;

      my $pmac = lc(($S->{blocks}{details_partner_lacp_pdu}{system_mac_address} // ''));
      $ok = 0 if !$pmac || $pmac eq '00:00:00:00:00:00';

      my $a = $S->{blocks}{details_actor_lacp_pdu}{port_state};
      my $p = $S->{blocks}{details_partner_lacp_pdu}{port_state};
      $ok = 0 if !defined $a || $a != 61 || !defined $p || $p != 61;

      $usable++ if $ok;
   }

   $perf->{usable_ports} = $usable;

   if ($usable == 0) {
      $rc = worst_rc($rc, 2);
      push @$msgs, "no_usable_ports";
   } elsif ($usable == 1) {
      $rc = worst_rc($rc, 1);
      push @$msgs, "redundancy_lost";
   }

   return ($rc, $msgs, $perf);
}



############################################
# Active-backup evaluator
############################################

sub eval_active_backup {
   #
   print "   running eval_active_backup subroutine \n" if ($verbose eq "yes");
   #
   my ($B) = @_;
   print "      calling eval_common subroutine \n" if ($verbose eq "yes");
   my ($rc, $msgs, $perf) = eval_common($B);

   my @ifs = keys %{ $B->{slaves} };
   my $up = 0;
   for my $if (@ifs) {
      $up++ if lc(($B->{slaves}{$if}{top}{mii_status} // '')) eq 'up';
   }

   $perf->{slaves_up} = $up;

   if ($up == 0) {
      $rc = worst_rc($rc, 2);
      push @$msgs, "no_slaves_up";
   } elsif ($up == 1) {
      $rc = worst_rc($rc, 1);
      push @$msgs, "redundancy_lost";
   }

   return ($rc, $msgs, $perf);
}



############################################
# Balance-* / broadcast evaluator
# This covers balance-rr balance-tlb balance-alb
############################################

sub eval_balance {
   #
   print "   running eval_balance subroutine \n" if ($verbose eq "yes");
   #
   my ($B) = @_;
   my ($rc, $msgs, $perf) = eval_common($B);

   my $up = 0;
   for my $if (keys %{ $B->{slaves} }) {
      $up++ if lc(($B->{slaves}{$if}{top}{mii_status} // '')) eq 'up';
   }

   $perf->{slaves_up} = $up;

   if ($up == 0) {
      $rc = worst_rc($rc, 2);
      push @$msgs, "no_slaves_up";
   } elsif ($up == 1) {
      $rc = worst_rc($rc, 1);
      push @$msgs, "redundancy_lost";
   }

   return ($rc, $msgs, $perf);
}



############################################
# Dispatcher
############################################

sub evaluate_bond {
   #
   print "   running evaluate_bond subroutine \n" if ($verbose eq "yes");
   #
   my ($B) = @_;
   print "      calling parse_mode_family subroutine \n" if ($verbose eq "yes");
   my $mode = parse_mode_family($B->{top}{bonding_mode});
   return eval_lacp($B)          if $mode eq 'lacp';
   return eval_active_backup($B) if $mode eq 'active_backup';
   return eval_balance($B)       if $mode eq 'balance' || $mode eq 'broadcast';
   # UNKNOWN: unsupported or missing bonding mode
   return (3, ["unknown_mode"], {});
}								#end of subroutine









# make these variables global so they will be visible to print_output subroutine
my ($ALL,$overall_rc,@summary,%perf);
$overall_rc = 0;					#initialize variable
sub get_all_bond_details {
   #
   print "running get_all_bond_details subroutine \n" if ($verbose eq "yes");
   #
   print "   calling read_all_bonds_into_hash subroutine \n" if ($verbose eq "yes");
   $ALL = read_all_bonds_into_hash();
   if (!keys %$ALL) {
      print "UNKNOWN - no bonding interfaces found\n";
      exit $UNKNOWN;
   }
    
   for my $bond (sort keys %$ALL) {
      my ($rc, $msgs, $p) = evaluate_bond($ALL->{$bond});
      $overall_rc = worst_rc($overall_rc, $rc);

      my $cap = $p->{usable_ports} // $p->{slaves_up} // '';
      my $hint = @$msgs ? $msgs->[0] : 'healthy';

      push @summary, "$bond:" . rc_label($rc) . ($cap ne '' ? "($cap)" : '') . "[$hint]";
      #
      # capture all the performance data into a hash
      #
      for my $k (keys %$p) {
         $perf{"${bond}_$k"} = $p->{$k};
      }
   }
   #
   # join the nagios output message and performance data into readable output
   #
   $output_message = rc_label($overall_rc) . " - bonds " . join(' ; ', @summary);
   $perf_data = join(' ', map { "$_=$perf{$_}" } sort keys %perf);
   print "end of get_all_bond_details subroutine \n" if ($verbose eq "yes");
}								#end of subroutine




############################################
# print output message
############################################

sub print_output {
   #
   print "running print_output subroutine \n" if ($verbose eq "yes");
   #
   # print the nagios output and return code
   #
   print "$output_message | $perf_data\n";
   print_to_outputfile; 			# save the output to a temporary file in case this script needs root permissions to run from cron
   exit $overall_rc;
}							#end of subroutine



############################################
# main body of script
############################################
get_options;
sanity_checks;
check_for_output_file;
get_all_bond_details;
print_output;
